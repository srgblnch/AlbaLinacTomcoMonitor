#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        AlbaLinacTomco.py
## 
## Project :     Linac's Tomco
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################

"""Thin device to monitor an Adlink card connected to the Linac's Tomco to monitor this readings and provide the user with statistical information"""

__all__ = ["AlbaLinacTomco", "AlbaLinacTomcoClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(AlbaLinacTomco.additionnal_import) ENABLED START -----#
import functools
import time
from TomcoMonitor import AttributeMonitor
from taurus import Logger
import traceback

def AttrExc(function):
    '''Decorates commands so that the exception is logged and also raised.
    '''
    #TODO: who has self._trace?
    def nestedMethod(self, attr, *args, **kwargs):
        inst = self #< for pychecker
        try:
            return function(inst, attr, *args, **kwargs)
        except Exception, exc:
            traceback.print_exc(exc)
            #self._trace = traceback.format_exc(exc)
            raise
    functools.update_wrapper(nestedMethod,function)
    return nestedMethod

def latin1(x):
  return x.decode('utf-8').replace(u'\u2070', u'\u00b0').\
      replace(u'\u03bc',u'\u00b5').encode('latin1')

#----- PROTECTED REGION END -----#	//	AlbaLinacTomco.additionnal_import

## Device States Description
## INIT : 
## ON : 
## FAULT : 

class AlbaLinacTomco (PyTango.Device_4Impl):

    #--------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(AlbaLinacTomco.global_variables) ENABLED START -----#
    #---- #state segment

    def change_state(self,newstate,cleanImportantLogs=False):
        '''
           This method is like an overload of the set_state, but includes
           a push event of this attribute.
        '''
        self.debug_stream("In change_state(%s)"%(str(newstate)))
        if newstate != self.get_state():
            self.set_state(newstate)
            self.push_change_event('State',newstate)
        if cleanImportantLogs:
            self.cleanAllImportantLogs()

    def addStatusMsg(self,text=None,important=False):
        '''
           The tango Status shall be a human readable message of the behaviour 
           of the device. With this method, text messages can be set in the 
           status attribute, with the extra feature to allow the device to
           remember (and maintain in the status message) some part messages,
           in order to merge them in one output.
        '''
        self.debug_stream("In %s::addStatusMsg(%r,important=%s)"
                          %(self.get_name(),text,important))
        if text == None or len(text) == 0:
            status = "The device is in %s state.\n"%(self.get_state())
        else:
            if not text in self._important_logs:
                status = "%s\n"%(text)
            else:
                status = ""
        for ilog in self._important_logs:
            status = "%s%s\n"%(status,ilog)
        self.set_status(status)
        self.push_change_event('Status',status)
        if important and not text in self._important_logs:
            self._important_logs.append(text)

    def cleanAllImportantLogs(self):
        '''
           With the feature of remember past messages to the status text 
           collection, it shall be also a way to clean up them.
        '''
        self.debug_stream("In %s::cleanAllImportantLogs()"%self.get_name())
        self._important_logs = []
        self.addStatusMsg("")
    #---- end state segment

    #---- #dynattr segment
    def _addDynAttribute(self,attrName,attrType,dim=None,expert=False,
                         memorized=None,label=None,description=None,units=None,
                         format=None,events=True,**kwargs):
        attr,readmethod,writemethod = self.__buildAttr(attrName,attrType,dim,
                                                       **kwargs)
        self.__setupAttrProp(attr,expert,memorized,label,description,units,
                             format)
        self.add_attribute(attr,r_meth=readmethod,w_meth=writemethod)
        if events:
            self.__setupEvents(attrName)

    def __buildAttr(self,attrName,attrType,dim,**kwargs):
        if type(dim) == list:
            if len(dim) == 1:
                return self._addDyn1DAttribute(attrName,attrType,dim,**kwargs)
            elif len(dim) == 2:
                return self._addDyn2DAttribute(attrName,attrType,dim,**kwargs)
            else:
                raise IndexError("Imposible to build %d dimensional "\
                                 "attribute %s"%(len(dim),attrName))
        else:
            return self._addDyn0DAttribute(attrName,attrType,**kwargs)
        return 

    def __setupAttrProp(self,attr,expert,memorized,label,description,units,
                        format):
        if expert:
            attr.set_disp_level(PyTango.DispLevel.EXPERT)
        if memorized:
                    attr.set_memorized()
        if label or description or units or format:
            aprop = PyTango.UserDefaultAttrProp()
            if label != None:
                aprop.set_label(latin1(label))
            if description:
                aprop.set_description(latin1(description))
            if units:
                aprop.set_unit(latin1(units))
            if format:
                aprop.set_format(format)
            attr.set_default_properties(aprop)

    def __setupEvents(self,attrName):
        self.set_change_event(attrName,True,False)
        
    def _addDyn0DAttribute(self,attrName,attrType,rw=False,expert=False,
                           **kwargs):
        if rw:
            attr = PyTango.Attr(attrName,attrType, PyTango.READ_WRITE)
            w_meth = AttrExc(getattr(self,'write_0D%s_attr'
                                         %('_expert' if expert else '')))
        else:
            attr = PyTango.Attr(attrName,attrType, PyTango.READ)
            w_meth = None
        r_meth = AttrExc(getattr(self,'read_0D%s_attr'
                                 %('_expert' if expert else '')))
        return attr,r_meth,w_meth
        
    def _addDyn1DAttribute(self,attrName,attrType,dim,rw=False,expert=False,
                           **kwargs):
        if rw:
            attr = PyTango.SpectrumAttr(attrName,attrType,PyTango.READ_WRITE,
                                        dim[0])
            w_meth = AttrExc(getattr(self,'write_1D%s_attr'
                                         %('_expert' if expert else '')))
        else:
            attr = PyTango.SpectrumAttr(attrName,attrType,PyTango.READ,dim[0])
            w_meth = None
        r_meth = AttrExc(getattr(self,'read_1D%s_attr'
                                 %('_expert' if expert else '')))
        return attr,r_meth,w_meth
        
    def _addDyn2DAttribute(self,attrName,attrType,dim,rw=False,expert=False,
                           **kwargs):
        if rw:
            attr = PyTango.ImageAttr(attrName,attrType,PyTango.READ_WRITE,
                                     dim[0],dim[1])
            w_meth = AttrExc(getattr(self,'write_2D%s_attr'
                                         %('_expert' if expert else '')))
        else:
            attr = PyTango.ImageAttr(attrName,attrType,PyTango.READ,
                                     dim[0],dim[1])
            w_meth = None
        r_meth = AttrExc(getattr(self,'read_2D%s_attr'
                                 %('_expert' if expert else '')))
        return attr,r_meth,w_meth
    
    @AttrExc
    def read_0D_attr(self,attr):
        attrName = attr.get_name()
        k = attrName.split("_Mean")[0]
        if k in self._monitor.keys():
            attr.set_value(self._monitor[k].composed)
        else:
            raise AttributeError("Not found %s as attribute"%(attrName))

    @AttrExc
    def write_0D_attr(self,attr):
        pass

    @AttrExc
    def read_0D_expert_attr(self,attr):
        pass

    @AttrExc
    def write_0D_expert_attr(self,attr):
        pass

    @AttrExc
    def read_1D_attr(self,attr):
        attrName = attr.get_name()
        k = attrName
        if k in self._monitor.keys():
            value = self._monitor[k].subsignals
            attr.set_value(value,len(value))
        else:
            raise AttributeError("Not found %s as attribute"%(attrName))

    @AttrExc
    def write_1D_attr(self,attr):
        pass

    @AttrExc
    def read_1D_expert_attr(self,attr):
        pass

    @AttrExc
    def write_1D_expert_attr(self,attr):
        pass

    @AttrExc
    def read_2D_attr(self,attr):
        pass

    @AttrExc
    def write_2D_attr(self,attr):
        pass

    @AttrExc
    def read_2D_expert_attr(self,attr):
        pass

    @AttrExc
    def write_2D_expert_attr(self,attr):
        pass

    def monitorCallback(self,caller):
        self.debug_stream("received from %s: %s , %s"
                          %(caller.name,caller.subsignals,caller.composed))
        if caller.groupName in self._monitor.keys():
            self._monitor[caller.groupName]
            self.fireEvent(caller.groupName,caller.subsignals)
            self.fireEvent("%s_Mean"%caller.groupName,caller.composed)

    #---- done dynattr segment
    
    #---- #events segment
    
    def fireEvent(self,attrName,value,timestamp=None,
                  quality=PyTango.AttrQuality.ATTR_VALID):
        '''Like overload the push_change_event to have logging of it.
        '''
        if not timestamp:
            timestamp = time.time()
        self.debug_stream("fireEvent for %s: %s (%s)"%(attrName,value,quality))
        self.push_change_event(attrName,value,timestamp,quality)
    
    #---- done events segment
    
    #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.global_variables

    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        AlbaLinacTomco.init_device(self)
        #----- PROTECTED REGION ID(AlbaLinacTomco.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(AlbaLinacTomco.delete_device) ENABLED START -----#
        del self._FW_500MHz
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        #----- PROTECTED REGION ID(AlbaLinacTomco.init_device) ENABLED START -----#
        self._important_logs = []
        self.set_change_event('State',True,False)
        self.set_change_event('Status',True,False)
        self.change_state(PyTango.DevState.INIT)
        try:
            self._monitor = {}
            if not self.deviceSource:
                raise Exception("deviceSource property not defined")
            if not self.FW_500MHz_Source:
                raise Exception("FW_500MHz_Source property not defined")
            groupName = 'FW_500MHz'
            self._monitor[groupName] = AttributeMonitor(self.deviceSource,
                                       self.FW_500MHz_Source,
                                       groupName=groupName,
                                       callback=self.monitorCallback,
                                       logLevel=Logger.info)
            attrName = groupName
            self._addDynAttribute(attrName,PyTango.DevDouble,dim=[3])
            attrName = "%s_Mean"%(groupName)
            self._addDynAttribute(attrName,PyTango.DevDouble)
            self.change_state(PyTango.DevState.ON)
            self.addStatusMsg("")
        except Exception,e:
            msg = "Cannot create the monitor: %s"%(e)
            self.change_state(PyTango.DevState.FAULT)
            self.addStatusMsg(msg,important=True)
            self.error_stream(msg)
            traceback.print_exc()
            
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(AlbaLinacTomco.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.always_executed_hook

    #-----------------------------------------------------------------------------
    #    AlbaLinacTomco read/write attribute methods
    #-----------------------------------------------------------------------------
    
    
    
        #----- PROTECTED REGION ID(AlbaLinacTomco.initialize_dynamic_attributes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.initialize_dynamic_attributes
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(AlbaLinacTomco.read_attr_hardware) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.read_attr_hardware


    #-----------------------------------------------------------------------------
    #    AlbaLinacTomco command methods
    #-----------------------------------------------------------------------------
    

    #----- PROTECTED REGION ID(AlbaLinacTomco.programmer_methods) ENABLED START -----#
    def initialize_dynamic_attributes(self):
        pass
    #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.programmer_methods

class AlbaLinacTomcoClass(PyTango.DeviceClass):
    #--------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(AlbaLinacTomco.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.global_class_variables

    def dyn_attr(self, dev_list):
        """Invoked to create dynamic attributes for the given devices.
        Default implementation calls
        :meth:`AlbaLinacTomco.initialize_dynamic_attributes` for each device
    
        :param dev_list: list of devices
        :type dev_list: :class:`PyTango.DeviceImpl`"""
    
        for dev in dev_list:
            try:
                dev.initialize_dynamic_attributes()
            except:
                import traceback
                dev.warn_stream("Failed to initialize dynamic attributes")
                dev.debug_stream("Details: " + traceback.format_exc())
        #----- PROTECTED REGION ID(AlbaLinacTomco.dyn_attr) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.dyn_attr

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'deviceSource':
            [PyTango.DevString,
            "device from where data will come from",
            [] ],
        'FW_500MHz_Source':
            [PyTango.DevString,
            "attribute of the device from where the data will come from",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        }


    #    Attribute definitions
    attr_list = {
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(AlbaLinacTomcoClass,AlbaLinacTomco,'AlbaLinacTomco')
        #----- PROTECTED REGION ID(AlbaLinacTomco.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	AlbaLinacTomco.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e

if __name__ == '__main__':
    main()
